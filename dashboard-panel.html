<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-styles/typography.html">
<link rel="import" href="../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../../bower_components/paper-spinner/paper-spinner.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../bower_components/chart-elements/chart-elements.html">

<link rel="import" href="panel-edit.html">

<dom-module id="dashboard-panel">
    <template>
        <style>
             :host {
                box-sizing: border-box;
                transition: height 500ms ease-in;
                min-width: 400px;
                min-height: 300px;
            }

            paper-spinner {
                position: relative;
                left: calc(50% - 14px);
                top: calc(50% - 14px);
            }

            paper-icon-button {
                opacity: 0.5;
            }

            chart-line {
                min-width: 400px;
                min-height: 300px;
            }

            .head {
                align-items: center;
                float: right;
                margin-bottom: 0px;
                margin-top: 32px;
            }
        </style>

        <iron-ajax id="panelDataRequest" handle-as="json" method="GET" contentType="application/json" url="[[_computeUrl(datasourceUri)]]"
            params="[[params]]" loading="{{loading}}" on-response="_handlePanelResponse" debounce-duration="300"></iron-ajax>

        <div class="head layout horizontal">
            <template is="dom-if" if="[[panel.editable]]">
                <panel-edit date-format="{{chartAxis.x.tick.format}}" step={{step}} panel="{{panel}}"></panel-edit>
            </template>
            <paper-icon-button icon="icons:close" on-tap="deletePanel" hidden$="[[!_computeIsPanelRemovable(panel)]]"></paper-icon-button>
        </div>
        <template is="dom-if" if="[[_isText(panel)]]">
            <div>[[panel.content]]</div>
        </template>
        <template is="dom-if" if="[[_isSinglestat(panel)]]">
            <div>[[panel.prefix]] [[panel.postfix]] [[panel.valueMaps.0.op]]</div>
        </template>
        <paper-spinner active="[[loading]]"></paper-spinner>
    </template>
    <script>
        function nFormatter(num, digits) {
            var si = [
                { value: 1E18, symbol: "E" },
                { value: 1E15, symbol: "P" },
                { value: 1E12, symbol: "T" },
                { value: 1E9, symbol: "G" },
                { value: 1E6, symbol: "M" },
                { value: 1E3, symbol: "k" }
            ], rx = /\.0+$|(\.[0-9]*[1-9])0+$/, i;
            for (i = 0; i < si.length; i++) {
                if (num >= si[i].value) {
                    return (num / si[i].value).toFixed(digits).replace(rx, "$1") + si[i].symbol;
                }
            }
            return num.toFixed(digits).replace(rx, "$1");
        }

        Polymer({
            is: 'dashboard-panel',
            properties: {
                from: {
                    type: String,
                },
                to: {
                    type: String,
                },
                timeRangeDurationInMinutes: {
                    type: Number
                },
                step: {
                    type: String,
                },
                params: {
                    type: Object
                },
                rowHeight: {
                    type: Number,
                    notify: true
                },
                refreshInterval: {
                    type: Number,
                    value: 0,
                },
                hasRenderedData: {
                    type: Boolean,
                    value: false
                },
                panel: {
                    type: Object,
                },
                chartElement: {
                    type: Object
                },
                chartData: {
                    type: Object,
                    value: function () {
                        return {
                            'datasets': []
                        }
                    }
                },
                chartOptions: {
                    type: Object,
                    value: {
                        title: {
                            display: true,
                            text: ''
                        },
                        legend: {
                            position: 'right'
                        },
                        tooltips: {
                            intersect: false,
                            filter: function (tooltip, data) {
                                // ugly hack to get unit from Y axis scaleLabel
                                var unit = Object.values(data.datasets[0]._meta)[0].controller.chart.options.scales.yAxes[0].scaleLabel.labelString;
                                tooltip.yLabel = nFormatter(Number(tooltip.yLabel), 5) + unit;
                                return tooltip;
                            }
                        },
                        responsive: true,
                        maintainAspectRatio: false,
                        elements: { point: { radius: 1 } },
                        animation: { easing: "linear", duration: 200 },
                        cubicInterpolationMode: "monotone",
                        gridLines: { drawOnChartArea: false },
                        scales: {
                            yAxes: [{
                                stacked: false,
                                ticks: {
                                    callback: function (label, index, labels) {
                                        return nFormatter(label, 5);
                                    },
                                    beginAtZero: true
                                },
                                scaleLabel: {
                                    display: true,
                                    labelString: ""
                                }
                            }],
                            xAxes: [{
                                type: 'time',
                                time: {
                                    minUnit: 'minute',
                                    displayFormats: {
                                        minute: 'h:mm a'
                                    }
                                },
                                ticks: {
                                    autoSkip: true,
                                    autoSkipPadding: 10,
                                }
                            }]
                        }
                    }
                },
                fillColorArray: {
                    type: Array,
                    value: ["rgba(0,155,155,0.1)", "rgba(153,255,51,0.1)", "rgba(255,153,0,0.1)", "rgba(155,0,155,0.1)", "rgba(155,0,0,0.1)", "rgba(0,155,0,0.1)", "rgba(0,0,0,0.1)", "rgba(0,0,200,0.1)", "rgba(200,0,200,0.1)",
                        "rgba(255,255,0,0.1)"
                    ]
                },
                lineColorArray: {
                    type: Array,
                    value: ["rgba(0,155,155,0.5)", "rgba(153,255,51,0.5)", "rgba(255,153,0,0.5)", "rgba(155,0,155,0.5)", "rgba(155,0,0,0.5)", "rgba(0,155,0,0.5)", "rgba(0,0,0,0.5)", "rgba(0,0,200,0.5)", "rgba(200,0,200,0.5)",
                        "rgba(255,255,0,0.5)"
                    ]
                },
                loading: {
                    type: Boolean,
                    value: false
                },
                datasourceUri: {
                    type: String,
                    reflectToAttribute: true
                },
                replaceTargets: {
                    type: Object,
                    value: {}
                },
                intervalId: String,
                index: Number
            },

            listeners: {
                'panelChanged': '_updatePanel'
            },

            observers: [
                '_updateParams(from, to, refreshInterval, panel.targets, datasourceType)'
            ],

            attached: function () {
                console.debug('panel attached', this.panel.id, this.datasourceType);
            },

            detached: function () {
                console.debug('panel detached', this.panel.id, this.datasourceType);
            },

            ready: function () {

            },

            deletePanel: function (e) {
                this.cancelAsync(this.intervalId);
                this.intervalId = 0;
                this.loading = true;
                this.fire('delete-panel', {
                    panelId: this.panel.id,
                    index: this.index,
                    panel: this
                });
            },

            _timeRangeUpdated: function () {
                console.debug("_timeRangeUpdated", this.to, this.from);
                // clear previous async task
                if (this.intervalId) {
                    this.cancelAsync(this.intervalId);
                    this.intervalId = 0;
                }
                this.hasRenderedData = false;
                // TODO unload existing chart data
                this._updateStep();
                this._generateDataRequest();
            },

            _updateStep: function () {
                var from = this.from, to = this.to, datasourceType = this.datasourceType;
                if (this.datasourceType != 'mist.monitor')
                    return; // step is needed only for mist.monitor datasource
                var steps = ["10sec", "10min", "6h", "1d", "4d", "7d", "1month"];
                var timeDelta = this.timeRangeDurationInMinutes;
                if (timeDelta <= 60) { //less than an  hour
                    this.step = steps[0];
                } else if (timeDelta <= 1440) { //less than a day
                    this.step = steps[1];
                } else if (timeDelta <= 1440 * 7) { //less than a week
                    this.step = steps[2];
                } else if (timeDelta <= 43200) { //less than a month
                    this.step = steps[3];
                } else if (timeDelta < 259200) { //less than 6 months
                    this.step = steps[4];
                } else if (timeDelta <= 2 * 259200) { //less than year)
                    this.step = steps[5];
                } else { //more than year
                    this.step = steps[6];
                }
            },

            _generateDataRequest: function () {
                console.debug("generating data request");
                this.async(function () {
                    if (this.datasourceType == 'graphite') {
                        if (this.$.panelDataRequest.lastRequest)
                            this.$.panelDataRequest.lastRequest.abort()
                        this.$.panelDataRequest.generateRequest();
                    } else if (this.datasourceType == 'mist.monitor') {
                        //uncomment this for http calls
                        //return '/api/v1/clouds/' + this.panel.cloudIds[0] + '/machines/' + this.panel.machineIds[0] + '/stats';
                        var socket = document.querySelector('mist-socket');
                        var prefix = this.panel.machine || [false, false];
                        var payload = prefix.concat([this.params.start, this.params.stop, this.step, 0, this.params.metrics]);
                        // TODO abort last request
                        socket.getStats(payload, this._handlePanelResponse.bind(this));
                        this.set('loading', true);
                    }
                }, 200);
            },

            _computeGraphiteTimestamp: function (timestamp) {
                if (typeof timestamp != 'string')
                    return timestamp;
                ret = timestamp;
                if (ret.endsWith("m"))
                    ret = ret.replace("m", "min");
                ret = ret.replace("now", "");
                return ret;
            },

            _updatePanel: function (e) {
                if (this.panel.width) {
                    var w = this.panel.width;
                    // append 'px' if needed
                    if (typeof (w) == 'number' || !w.endsWith('%') && !w.endsWith('px'))
                        this.panel.width = w + 'px';
                    this.style.width = this.panel.width;
                } else if (this.panel.span) {
                    this.style.width = (100 * this.panel.span / 12) + '%';
                }

                if (this.panel.height) {
                    var h = this.panel.height;
                    // append 'px' if needed
                    if (typeof (h) == 'number' || !h.endsWith('%') && !h.endsWith('px'))
                        this.panel.height = h + 'px';
                    this.style.height = this.panel.height;
                } else if (this.rowHeight) {
                    if (typeof (this.rowHeight) == 'number' || !this.rowHeight.endsWith('%') && !this.rowHeight.endsWith('px'))
                        this.rowHeight = this.rowHeight + 'px';
                    this.style.height = this.rowHeight;
                }

                if (this.chartElement) {
                    this.chartElement.style.height = this.style.height;
                    this.chartElement.options.title.text = this.panel.title;
                    this.async(function () {
                        // set y-axis labelString - for some reason we need to wait until the chart is ready for it to get updated
                        var unit = this.panel.yaxes ? (this.panel.yaxes[0].label || this.panel.yaxes[0].format) : "";
                        if (this.chartElement.chart) {
                            this.chartElement.chart.scales['y-axis-0'].options.scaleLabel.labelString = unit;
                            //this.chartElement.chart.scales['x-axis-0'].options.time.min = + moment().relativeTime(this.from)._d;
                        }
                    }, 500);
                    //do this if there is a rendered panel
                    if (parseInt(this.offsetWidth)) {
                        var from = this.from.trim ? + moment().relativeTime(this.from)._d : this.from * 1000,
                            to = this.to.trim ? + moment().relativeTime(this.to)._d : this.to * 1000;
                        this.chartElement.options.scales.xAxes[0].time.min = from;
                        this.chartElement.options.scales.xAxes[0].time.max = to;
                        if (this.chartData)
                            this.chartElement.updateChart();
                    }
                }
            },

            _updateParams: function (from, to, refreshInterval, targets, datasourceType) {
                if (this.datasourceType == "graphite") {
                    //some graphite versions expect 'until' paramater and others "to"
                    var params = {
                        'format': 'json',
                        'from': this._computeGraphiteTimestamp(from),
                        'to': this._computeGraphiteTimestamp(to),
                        'until': this._computeGraphiteTimestamp(to)
                    },
                        tlist = [];
                    for (var i = 0; i < targets.length; i++) {
                        if (targets[i].target)
                            tlist.push(targets[i].target)
                    }
                    params['target'] = tlist;
                } else if (this.datasourceType == "mist.monitor") {
                    var params = {
                        'start': this._computeGraphiteTimestamp(from),
                        'stop': this._computeGraphiteTimestamp(to)
                    },
                        tlist = [];
                    for (var i = 0; i < targets.length; i++) {
                        tlist.push(targets[i].target)
                    }
                    params['metrics'] = tlist;
                }
                this.set('params', params);
                this._timeRangeUpdated();
            },

            _filterTarget: function (target) {
                var k = Object.keys(this.get('replaceTargets'));
                for (var i = 0; i < k.length; i++) {
                    target = target.replace(k[i], this.replaceTargets[k[i]])
                }
                return target;
            },

            _handlePanelResponse: function (e) {
                if (!this)
                    return;

                if (!this.chartElement) {
                    // console.log("dashboard panel ready",this.querySelector("chart-line"));
                    this.chartElement = document.createElement("chart-line");
                    this.chartElement.id = this._computePanelId(this.panel.id, this.panel.title);
                    this.chartElement.options = this.chartOptions;
                    this.chartElement.style.width = "100%";
                }

                // get data from response
                var data = e.detail ? e.detail.response : e;

                this.set('loading', false);

                if (this.chartElement.chart) {
                    if (!this.to.trim) {
                        this.chartElement.chart.options.scales.xAxes[0].time.max = 1000 * this.to;
                    } else {
                        this.chartElement.chart.options.scales.xAxes[0].time.max = + moment().relativeTime(this.to)._d;
                    }

                    if (!this.from.trim) {
                        this.chartElement.chart.options.scales.xAxes[0].time.min = 1000 * this.from;
                    } else {
                        this.chartElement.chart.options.scales.xAxes[0].time.min = + moment().relativeTime(this.from)._d;
                    }
                }

                var cols = this.transformData(data);

                if (!this.hasRenderedData) {
                    this.set('chartData', cols);
                    this.chartElement.data = cols
                    this.appendChild(this.chartElement);
                    this._loadDatatoGraphs(cols);
                } else if (this.to.trim != undefined) { // flow the new data if we auto refresh
                    this._flowDatatoGraphs(cols);
                }

                if (this.refreshInterval > 0 && document.contains(this)) {
                    var to = this.to;
                    if (typeof to == "string" && (to.trim().startsWith('now') || to.trim().startsWith('-') || to.trim() == ""))
                        this.async(function () {
                            if (this.hasRenderedData) {
                                if (this.datasourceType == "graphite") {
                                    this.set("params.from", "-2min");
                                } else if (this.datasourceType == "mist.monitor") {
                                    this.set("params.start", "-2min");
                                }
                            }
                            this._generateDataRequest();
                        }, this.refreshInterval);
                }
            },

            _loadDatatoGraphs: function (cols) {
                this.chartOptions.title.text = this.panel.title;
                this.set('loading', false);
                console.log('_loadDatatoGraphs', cols)
                if (this.panel.stack) {
                    this.chartOptions.scales.yAxes[0].stacked = true;
                } else {
                    this.chartOptions.scales.yAxes[0].stacked = false;
                }
                for (var i = 0; i < cols.datasets.length; i++) {
                    if (this.panel.stack) {
                        this.chartData.datasets[i].backgroundColor = this.fillColorArray[i % 10];
                    } else {
                        this.chartData.datasets[i].borderColor = this.lineColorArray[i % 10];
                        this.chartData.datasets[i].backgroundColor = 'transparent';
                    }
                    this.chartData.datasets[i].label = this._filterTarget(cols.datasets[i].label);
                }
                this._updatePanel();
                if (this.chartData.datasets.length) {
                    this.hasRenderedData = true;
                }
            },

            _flowDatatoGraphs: function (cols) {
                if (this.chartElement) {
                    this.chartElement.chart.options.scales.xAxes[0].time.max = + moment().relativeTime(this.to)._d;
                    this.chartElement.chart.options.scales.xAxes[0].time.min = + moment().relativeTime(this.from)._d;
                    //this.chartElement.updateChart();
                }
                for (var b = 0; b < this.chartData.datasets.length; b++) {
                    for (var a = this.chartData.datasets[b].data.length - 1; a >= 0; a--) {
                        //if we have greater or equal date
                        if (cols.datasets[b].data.length && cols.datasets[b].data[0].x >= this.chartData.datasets[b].data[a].x)
                            break;
                    }
                    Array.prototype.splice.apply(this.chartData.datasets[b].data, [a, cols.datasets[b].data.length].concat(cols.datasets[b].data));
                }
                for (var b = 0; b < this.chartData.datasets.length; b++) {
                    // remove datapoints that are outside the time window
                    for (var i = 0; i < this.chartData.datasets[b].data.length; i++)
                        if (this.chartData.datasets[b].data[i].x >= moment().relativeTime(this.from)._d)
                            break;
                    if (i)
                        this.chartData.datasets[b].data.splice(0, i);
                }
                if (this.chartElement) {
                    this.chartElement.updateChart();
                }
            },

            transformData: function (data) {
                // console.log('transformData',data);
                var columns = [],
                    response,
                    x = [],
                    points = [],
                    datanames = [];
                if (this.datasourceType == "mist.monitor") {
                    // for http
                    if (data.detail != null) {
                        response = data.detail.response;
                    } else {
                        response = data.metrics;
                    }
                    for (var metr in response) {
                        if (columns.length >= 20) // no more than 20 metrics per graph
                            break;
                        x = [];
                        points = [];
                        if (response[metr] != null) {
                            for (var i = 0; i < response[metr].datapoints.length; i++) {
                                points.push({
                                    x: new Date(response[metr].datapoints[i][1] * 1000),
                                    y: response[metr].datapoints[i][0]
                                })
                            }
                            datanames.push(response[metr].name);
                            columns.push(points);
                        }
                    }
                    var ret = {
                        labels: [],
                        datasets: []
                    };
                    for (var k = 0; k < datanames.length; k++) {
                        ret.datasets.push({
                            label: datanames[k],
                            data: columns[k]
                        })
                    }
                    return ret;
                } else { //for graphite
                    for (var j = 0; j < data.length; j++) {
                        x = [];
                        points = [];
                        if (data[j] != null) {
                            for (var i = 0; i < data[j].datapoints.length; i++) {
                                points.push({
                                    x: new Date(data[j].datapoints[i][1] * 1000),
                                    y: data[j].datapoints[i][0]
                                })
                            }
                            datanames.push(data[j].target);
                            columns.push(points);
                        }
                    }
                    var ret = {
                        labels: [],
                        datasets: []
                    };
                    for (var k = 0; k < datanames.length; k++) {
                        ret.datasets.push({
                            label: datanames[k],
                            data: columns[k]
                        })
                    }
                    return ret;

                }
            },

            _computeIsPanelRemovable: function (panel) {
                return panel.editable || panel.removable;
            },

            _computeUrl: function (datasourceUri) {
                return this.datasourceUri + '/render';
            },

            _isGraph: function (panel) {
                return panel.type == "graph"
            },

            _isDashlist: function (panel) {
                return panel.type == "dashlist"
            },

            _isText: function (panel) {
                return panel.type == "text"
            },

            _isSinglestat: function (panel) {
                return panel.type == "singlestat"
            },

            _isTable: function (panel) {
                return panel.type == "table"
            },

            _computePanelId: function (id, title) {
                return title.replace(/ /g, "-") + "-panel" + id;
            },

            _computeTitle: function (title) {
                if (title)
                    return title.replace(/_/g, " ");
                else
                    return "";
            }

        });
    </script>
</dom-module>
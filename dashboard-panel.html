<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-styles/typography.html">
<link rel="import" href="../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../../bower_components/paper-spinner/paper-spinner.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../bower_components/chart-elements/chart-elements.html">
<link rel="import" href="panel-edit.html">
<dom-module id="dashboard-panel">
    <template>
        <style>
             :host {
                float: left;
                display: inline-block;
                position: relative;
                padding: 4px;
                box-sizing: border-box;
                transition: height 500ms ease-in;
            }

            #target {
                font-weight: bold;
                text-align: left;
            }

            paper-material {
                width: 100%;
                padding: 0 16px 16px 16px;
                box-sizing: border-box;
                overflow: auto;
            }

            h3 {
                text-transform: uppercase;
                font-size: 16px;
                font-weight: 500;
                line-height: 36px;
                cursor: move;
            }

            .head {
                align-items: center;
                float: right;
            }

            paper-spinner {
                position: absolute;
                left: 50%;
                top: 24px;
            }

            paper-icon-button {
                opacity: 0.32;
            }
        </style>
        <iron-ajax id="panelDataRequest" handle-as="json" method="GET"
            contentType="application/json"
            url="[[_computeUrl(datasourceUri)]]"
            params="[[params]]" loading="{{loading}}"
            on-response="_handlePanelResponse"
            debounce-duration="300"></iron-ajax>

        <paper-material elevation="0">
            <div class="head layout horizontal">
                <template is="dom-if" if="[[panel.editable]]">
                    <panel-edit date-format="{{chartAxis.x.tick.format}}" step={{step}} panel="{{panel}}"></panel-edit>
                </template>
                <paper-icon-button icon="icons:close" on-tap="deletePanel" hidden$="[[!_computeIsPanelRemovable(panel)]]"></paper-icon-button>
            </div>
            <template is="dom-if" if="[[_isText(panel)]]">
                <div>[[panel.content]]</div>
            </template>
            <template is="dom-if" if="[[_isSinglestat(panel)]]">
                <div>[[panel.prefix]] [[panel.postfix]] [[panel.valueMaps.0.op]]</div>
            </template>
            <template is="dom-if" if="[[_isGraph(panel)]]">
                <paper-spinner active="[[loading]]"></paper-spinner>
                <chart-line id="[[_computePanelId(panel.id, panel.title)]]" data="[[chartData]]" options="[[chartOptions]]" type="line" style$="width:100%; height: [[rowHeight]]"></chart-line>
            </template>
            <template is="dom-if" if="[[_isDashlist(panel)]]">
                <!-- TODO -->
            </template>
            <template is="dom-if" if="[[_isTable(panel)]]">
                <!-- TODO -->
            </template>
        </paper-material>
    </template>
    <script>
        function nFormatter(num, digits) {
            var si = [
                { value: 1E18, symbol: "E" },
                { value: 1E15, symbol: "P" },
                { value: 1E12, symbol: "T" },
                { value: 1E9,  symbol: "G" },
                { value: 1E6,  symbol: "M" },
                { value: 1E3,  symbol: "k" }
            ], rx = /\.0+$|(\.[0-9]*[1-9])0+$/, i;
            for (i = 0; i < si.length; i++) {
                if (num >= si[i].value) {
                    return (num / si[i].value).toFixed(digits).replace(rx, "$1") + si[i].symbol;
                }
            }
            return num.toFixed(digits).replace(rx, "$1");
        }
        var unit = "";
        Polymer({
            is: 'dashboard-panel',
            properties: {
                from: {
                    type: String,
                },
                to: {
                    type: String,
                },
                step: {
                    type: String,
                },
                params: {
                    type: Object
                },
                rowHeight: {
                    type: Number,
                    notify: true
                },
                refreshInterval: {
                    type: Number,
                    value: 0,
                },
                hasRenderedData: {
                    type: Boolean,
                    value: false
                },
                panel: {
                    type: Object,
                },
                chartElement: {
                    type: Object
                },
                chartData: {
                    type: Object,
                    value: {}
                },
                chartOptions: {
                    type: Object,
                    value: {
                        title: {
                            display: true,
                            text: this.panel ? this.panel.title : ''
                        },
                        legend: {
                            position: "bottom"
                        },
                        tooltips: {
                            intersect: false,
                            filter: function(tooltip) {
                                tooltip.yLabel = nFormatter(Number(tooltip.yLabel), 5) + unit;
                                return tooltip;
                            }
                        },
                        responsive: true,
                        maintainAspectRatio: false,
                        elements: {point: { radius: 1 }},
                        //animation: {easing: "easeInOutCirc", duration: 200},
                        cubicInterpolationMode: "monotone",
                        gridLines: {drawOnChartArea: false},
                        scales: {
                            yAxes: [{
                                stacked: false,
                                ticks: {
                                    callback: function(label, index, labels) {
                                        return nFormatter(label, 5);
                                    }
                                },
                                scaleLabel: {
                                    display: true,
                                    labelString: ""
                                }
                            }],
                            xAxes: [{
                                type: 'time',
                                position: 'bottom'
                            }]
                        }
                    }
                },
                colorArray: {
                    type: Array,
                    value: ["rgba(0,155,155,0.1)", "rgba(153,255,51,0.1)", "rgba(255,153,0,0.1)", "rgba(155,0,155,0.1)", "rgba(155,0,0,0.1)", "rgba(0,155,0,0.1)", "rgba(0,0,0,0.1)", "rgba(0,0,200,0.1)", "rgba(200,0,200,0.1)",
                        "rgba(255,255,0,0.1)"
                    ]
                },
                loading: {
                    type: Boolean,
                    value: false
                },
                datasourceUri: {
                    type: String,
                    reflectToAttribute: true
                },
                replaceTargets: {
                    type: Object,
                    value: {}
                },
                intervalId: String,
                index: Number,
                panelDataTimeDiff:Array
            },

            listeners: {
                'panelChanged': '_updatePanel'
            },

            observers: [
                '_updateParams(from, to, refreshInterval, panel.targets, datasourceType)',
                '_updatePanel(panel)'
            ],

            attached: function() {
                console.debug('panel attached', this.panel.id, this.datasourceType);
            },

            detached: function() {
                console.debug('panel detached', this.panel.id, this.datasourceType);
            },

            ready: function() {
                this.chartElement = this.querySelector("chart-line");
            },

            deletePanel: function(e) {
                this.cancelAsync(this.intervalId);
                this.intervalId = 0;
                this.loading = true;
                this.fire('delete-panel', {
                    panelId: this.panel.id,
                    index: this.index,
                    panel: this
                });
            },

            _timeRangeUpdated: function() {
                console.debug("_timeRangeUpdated", this.to, this.from);
                // clear previous async task
                if (this.intervalId){
                    this.cancelAsync(this.intervalId);
                    this.intervalId = 0;
                }
                this.hasRenderedData = false;
                // TODO unload existing chart data
                this._updateStep();
                this._generateDataRequest();
            },

            _updateStep: function() {
                var from = this.from, to = this.to, datasourceType = this.datasourceType;
                console.debug('_updateStep', this.panel.id, from, to, datasourceType);
                //console.warn('from/to updated', this.panel, from, to);
                if (this.datasourceType != 'mist.monitor')
                    return; // step is needed only for mist.monitor datasource
                // We need to calculate "from" and "to" in seconds in order to
                // subtract them
                var fromInSeconds, toInSeconds, parsedDigits,
                    now = Math.floor(new Date().getTime() / 1000);
                if (typeof from === "string") {
                    // get digits in string
                    parsedDigits = parseInt(from.match(/\d+/g));
                    if (from.search("y") >= 0) { // time in years
                        fromInSeconds = now - parsedDigits * 31556952;
                    } else if (from.search("month") >= 0) { // time in months
                        fromInSeconds = now - parsedDigits * 2629746;
                    } else if (from.search("d") >= 0) { // time in days
                        fromInSeconds = now - parsedDigits * 86400;
                    } else if (from.search("h") >= 0) { // time in hours
                        fromInSeconds = now - parsedDigits * 3600;
                    } else if (from.search("m") >= 0) { // time in mins
                        fromInSeconds = now - parsedDigits * 60;
                    } else { // time in secs
                        fromInSeconds = parsedDigits;
                    }
                } else if (typeof from === 'number') {
                    fromInSeconds = from;
                } else {
                    //console.error('Unsupported type for "from"', typeof from);
                    return;
                }
                //console.warn('fromInSeconds string', fromInSeconds);
                if (typeof to === "string") {
                    if (to == "now" || to == "") {
                        toInSeconds = now;
                    } else {
                        // get digits in string
                        parsedDigits = parseInt(to.match(/\d+/g));
                        if (!parsedDigits || parsedDigits === NaN) {
                            console.error('Invalid value for "to"', to);
                            return;
                        }
                        if (to.search("y") >= 0) { // time in years
                            toInSeconds = now - parsedDigits * 31556952;
                        } else if (to.search("month") >= 0) { // time in months
                            toInSeconds = now - parsedDigits * 2629746;
                        } else if (to.search("d") >= 0) { // time in days
                            toInSeconds = now - parsedDigits * 86400;
                        } else if (to.search("h") >= 0) { // time in hours
                            toInSeconds = now - parsedDigits * 3600;
                        } else if (to.search("m") >= 0) { // time in mins
                            toInSeconds = now - parsedDigits * 60;
                        } else { // time in secs
                            toInSeconds = now - parsedDigits;
                        }
                    }
                } else if (typeof to === 'number') {
                    toInSeconds = to;
                } else {
                    console.error('Unsupported type for "to"', typeof to);
                    return;
                }
                //console.warn('toInSeconds', toInSeconds);
                var steps = ["10sec", "10min", "6h", "1d", "4d", "7d", "1month"];
                if (!this.refreshOn) {
                    var timeDelta = toInSeconds - fromInSeconds;
                    if (timeDelta <= 3600) { //less than an  hour
                        this.step = steps[0];
                    } else if (timeDelta <= 86400) { //less than a day
                        this.step = steps[1];
                    } else if (timeDelta <= 2629746) { //less than a month
                        this.step = steps[3];
                    } else if (timeDelta <= 2629746 * 6) { //less than 6 months
                        this.step = steps[3];
                    } else if (timeDelta <= 31556952) { //less than year
                        this.step = steps[4];
                    } else { //more than year
                        this.step = steps[6];
                    }
                } else {
                    if (steps.indexOf(this.step) > 3) {
                        this.step = steps[2];
                    }
                }
            },

            _generateDataRequest: function() {
                console.debug("generating data request");
                this.async(function() {
                    if (this.datasourceType == 'graphite') {
                        if (this.$.panelDataRequest.lastRequest)
                            this.$.panelDataRequest.lastRequest.abort()
                        this.$.panelDataRequest.generateRequest();
                    } else if (this.datasourceType == 'mist.monitor') {
                        //uncomment this for http calls
                        //return '/api/v1/clouds/' + this.panel.cloudIds[0] + '/machines/' + this.panel.machineIds[0] + '/stats';
                        var socket = document.querySelector('mist-socket');
                        var prefix = this.panel.machine || [false, false];
                        var payload = prefix.concat([this.params.start, this.params.stop, this.step, 0, this.params.metrics]);
                        // TODO abort last request
                        socket.getStats(payload, this._handlePanelResponse.bind(this));
                        this.set('loading', true);
                    }
                }, 200);
            },

            _computeGraphiteTimestamp: function(timestamp) {
                if (typeof timestamp != 'string')
                    return timestamp;
                ret = timestamp;
                if (ret.endsWith("m"))
                    ret = ret.replace("m", "min");
                ret = ret.replace("now", "");
                return ret;
            },

            resizeChart: function(e, detail, sender) {
                this.width = this.querySelector('paper-material').clientWidth;
                this.height = this.querySelector('paper-material').clientHeight;
                this.chartElement.resize({
                    height: this.height - 140,
                    width: this.width - 20
                });
                //this.rowHeight = this.height;
                this.panel.span = ((this.width + 30) / this.offsetWidth) * this.panel.span;
                if (this.panel.span > 12) {
                    this.panel.span = 12;
                }
                this.fire('resizeDone');
            },

            _updatePanel: function(e) {
                console.log('_updatePanel');
                if (this.chartElement){
                    this.chartElement.options.title.text = this.panel.title;
                    this.async(function() {
                        // set y-axis labelString - for some reason we need to wait until the chart is ready for it to get updated
                        unit = this.panel.yaxes ? (this.panel.yaxes[0].label || this.panel.yaxes[0].format) : "";
                        this.chartOptions.scales.yAxes[0].scaleLabel.labelString = unit;
                    }, 500);
                    this.chartElement.updateChart();
                }
            },

            _updateParams: function(from, to, refreshInterval, targets, datasourceType) {
                console.debug("_computeParams", from, to, targets, datasourceType);
                if (this.datasourceType == "graphite") {
                    //some graphite versions expect 'until' paramater and others "to"
                    var params = {
                            'format': 'json',
                            'from': this._computeGraphiteTimestamp(from),
                            'to': this._computeGraphiteTimestamp(to),
                            'until': this._computeGraphiteTimestamp(to)
                        },
                        tlist = [];
                    for (var i = 0; i < targets.length; i++) {
                        tlist.push(targets[i].target)
                    }
                    params['target'] = tlist;
                } else if (this.datasourceType == "mist.monitor") {
                    var params = {
                            'start': this._computeGraphiteTimestamp(from),
                            'stop': this._computeGraphiteTimestamp(to)
                        },
                        tlist = [];
                    for (var i = 0; i < targets.length; i++) {
                        tlist.push(targets[i].target)
                    }
                    params['metrics'] = tlist;
                }
                this.set('params', params);
                this._timeRangeUpdated();
            },

            _filterTarget: function(target) {
                var k = Object.keys(this.get('replaceTargets'));
                for (var i = 0; i < k.length; i++) {
                    target = target.replace(k[i], this.replaceTargets[k[i]])
                }
                return target;
            },

            _handlePanelResponse: function(e) {
                if (!this)
                    return;

                if (!this.chartElement)
                    this.chartElement = this.querySelector("chart-line");

                // get data from response
                var data = e.detail ? e.detail.response : e;

                // if no metrics are returned hide the panel, except if it's a custom python plugin
                if (!data.length && !Object.keys(data.metrics).length && this.panel.targets[0].target.indexOf('mist.python') == -1)
                    this.hidden = true;
                else if (this.hidden)
                    this.hidden = false;
                this.set('loading', false);
                var cols = this.transformData(data);

                if (!this.hasRenderedData) {
                    this._loadDatatoGraphs(cols);
                    this.hasRenderedData = true;
                } else { // flow the new data if we auto refresh
                    this._flowDatatoGraphs(cols);
                }

                if (this.refreshInterval > 0 && document.contains(this)) {
                    var to = this.to;
                    if (typeof to == "string" && (to.trim().startsWith('now') || to.trim().startsWith('-') || to.trim() == ""))
                        this.async(function() {
                          if (this.datasourceType == "graphite") {
                              this.set("params.from", "-2min");
                          } else if (this.datasourceType == "mist.monitor") {
                              this.set("params.start", this._lastDrawnPoint()-120);
                          }
                          this._generateDataRequest();
                        }, this.refreshInterval);
                }
            },

            _lastDrawnPoint:function(){
                var max=0;
                for (var i=0; i<this.chartData.datasets.length; i++){
                  if(this.chartData.datasets[i].data[this.chartData.datasets[i].data.length-1].x.getTime()/1000 >max){
                    max=this.chartData.datasets[i].data[this.chartData.datasets[i].data.length-1].x.getTime()/1000;
                  }
                }
                return max;
            },

            _loadDatatoGraphs: function(cols) {
                this.chartOptions.title.text = this.panel.title;
                this.set('loading', false);
                this.chartData = cols;

                if (this.panel.stack) {
                    this.chartOptions.scales.yAxes[0].stacked = true;
                } else {
                    this.chartOptions.scales.yAxes[0].stacked = false;
                }
                this.panelDataTimeDiff=[];
                for (var i = 0; i < this.chartData.datasets.length; i++) {
                    this.chartData.datasets[i].backgroundColor = this.colorArray[i%10];
                    this.chartData.datasets[i].label = this._filterTarget(this.chartData.datasets[i].label);
                    this.panelDataTimeDiff.push((this.chartData.datasets[i].data[this.chartData.datasets[i].data.length-1].x.getTime()/1000)-this.chartData.datasets[i].data[0].x.getTime()/1000);
                }
                this._updatePanel();
            },

            _flowDatatoGraphs: function(cols) {
                for (var b = 0; b < this.chartData.datasets.length; b++) {
                    var originalLength = this.chartData.datasets[b].data.length;

                    // Remove trailing nulls from the end
                    /*for (var c = cols.datasets[b].data.length - 1; c > 0; c--)
                        if (cols.datasets[b].data[c].y == null)
                            cols.datasets[b].data.pop();*/
                    for (var a = this.chartData.datasets[b].data.length - 1; a >= 0; a--) {
                        //if we have greater or equal date
                        if (cols.datasets[b].data.length && cols.datasets[b].data[0].x >= this.chartData.datasets[b].data[a].x) {
                            this.chartData.datasets[b].data.splice(a, originalLength - a);
                            this.chartData.datasets[b].data = this.chartData.datasets[b].data.concat(cols.datasets[b].data);
                            // remove as many datapoints from the beggining of the series as we added in the end
                            // FIXME we should only remove those that shouldn't be in the time window any more
                            //this.chartData.datasets[b].data.splice(0, this.chartData.datasets[b].data.length - originalLength);
                            for(var c=0; c<this.chartData.datasets[b].data.length; c++){
                              var timeDiff=(this.chartData.datasets[b].data[this.chartData.datasets[b].data.length-1].x.getTime()/1000)-this.chartData.datasets[b].data[c].x.getTime()/1000;
                              if(timeDiff <=this.panelDataTimeDiff[b]){
                                this.chartData.datasets[b].data.splice(0, c);
                                break;
                              }
                            }
                            break;
                        }
                    }
                }
                this.chartElement.updateChart();
            },

            transformData: function(data) {
                var columns = [],
                    response,
                    x = [],
                    points = [],
                    datanames = [];
                if (this.datasourceType == "mist.monitor") {
                    // for http
                    if (data.detail != null) {
                        response = data.detail.response;
                    } else {
                        response = data.metrics;
                    }
                    for (var metr in response) {
                        x = [];
                        points = [];
                        if (response[metr] != null) {
                            for (var i = 0; i < response[metr].datapoints.length; i++) {
                                if (response[metr].datapoints[i][0])
                                    points.push({
                                        x: new Date(response[metr].datapoints[i][1] * 1000),
                                        y: response[metr].datapoints[i][0]
                                    })
                            }
                            datanames.push(response[metr].name);
                            columns.push(points);
                        }
                    }
                    var ret = {
                        labels: [],
                        datasets: []
                    };
                    for (var k = 0; k < datanames.length; k++) {
                        ret.datasets.push({
                            label: datanames[k],
                            data: columns[k]
                        })
                    }
                    return ret;
                } else { //for graphite
                    for (var j = 0; j < data.length; j++) {
                        x = [];
                        points = [];
                        if (data[j] != null) {
                            for (var i = 0; i < data[j].datapoints.length; i++) {
                                points.push({
                                    x: new Date(data[j].datapoints[i][1] * 1000),
                                    y: data[j].datapoints[i][0]
                                })
                            }
                            datanames.push(data[j].target);
                            columns.push(points);
                        }
                    }
                    var ret = {
                        labels: [],
                        datasets: []
                    };
                    for (var k = 0; k < datanames.length; k++) {
                        ret.datasets.push({
                            label: datanames[k],
                            data: columns[k]
                        })
                    }
                    return ret;

                }
            },

            _computeIsPanelRemovable: function(panel) {
                return panel.editable || panel.removable;
            },

            _computeUrl: function(datasourceUri) {
                return this.datasourceUri + '/render';
            },

            _isGraph: function(panel) {
                return panel.type == "graph"
            },

            _isDashlist: function(panel) {
                return panel.type == "dashlist"
            },

            _isText: function(panel) {
                return panel.type == "text"
            },

            _isSinglestat: function(panel) {
                return panel.type == "singlestat"
            },

            _isTable: function(panel) {
                return panel.type == "table"
            },

            _computePanelId: function(id, title) {
                return title.replace(/ /g, "-") + "-panel" + id;
            },

            _computeTitle: function(title) {
                if (title)
                    return title.replace(/_/g, " ");
                else
                    return "";
            }

        });
    </script>
</dom-module>
